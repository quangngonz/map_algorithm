# Pathfinding Algorithm Visualizer (A-Level Computer Science)

This project implements and visualizes two fundamental graph search algorithms: Dijkstra's Algorithm and A\*. It's designed to help understand how these algorithms work to find the shortest path between nodes in a graph. The project uses `networkx` for graph manipulation and `matplotlib` for visualization. The algorithms are tested and the visualization tools are provided.

## Project Structure

The project is organized into the following files and directories:

- **`a_star.py`**: Contains the (currently incomplete) implementation of the A* algorithm. This is where you'll write the core A* logic. It uses helper functions from `unit_test/result.py` to run and visualize the results.
- **`dijkstra.py`**: Contains the (currently incomplete) implementation of Dijkstra's algorithm. Similar to `a_star.py`, this file will hold the Dijkstra logic and uses `unit_test/result.py`.
- **`graph.json`**: A sample graph represented in JSON format. This file is used as a default input for testing.
- **`unit_test/`**: This directory contains helper functions for generating, testing and visulizing the graphs.
  - **`generate_graph.py`**: Generates random graphs and saves them in the JSON format. It can also visualize the generated graph.
  - **`result.py`**: Contains testing functions `a_star_test` and `dijkstra_test`. These functions use `networkx`'s _built-in implementations_ to test your algorithms and visualize the results. This is _crucial_ for verifying your own implementations.
  - **`graph.json`**: Contains last graph that generated by `generate_graph.py`.

## Your Task: Implement the Algorithms

This project provides the framework, but the core implementations of Dijkstra's and A\* are left for you to complete. This is a hands-on learning exercise to solidify your understanding of these pathfinding algorithms.

**Specifically, you need to:**

1.  **Dijkstra's Algorithm (`dijkstra.py`):**

    - Complete the `dijkstra()` function. This function should take the graph (as a dictionary) and the starting node as input.
    - It should return a dictionary of shortest distances from the starting node to all other nodes.
    - You can use the provided `dijkstra_test` function in `unit_test/result.py` to check your implementation against a known correct solution (using `networkx`). This will be invaluable for debugging.

2.  **A\* Algorithm (`a_star.py`):**
    - Complete the `a_star()` function. This function takes the graph, starting node, and ending node as input.
    - It should return a tuple: `(path, length)`, where `path` is a list of nodes representing the shortest path, and `length` is the total length of that path. Return `(None, float('inf'))` if no path is found.
    - You'll also need to implement a `heuristic()` function. Start with a simple heuristic (like `abs(node - goal)`), and then experiment with others. Remember the heuristic must be admissible (never overestimate the distance to the goal).
    - Use the `a_star_test` function in `unit_test/result.py` to verify your implementation and visualize the results.
